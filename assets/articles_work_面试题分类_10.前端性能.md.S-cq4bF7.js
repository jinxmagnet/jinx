import{_ as i,o as l,c as e,R as a}from"./chunks/framework.ka86hsJC.js";const P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/work/面试题分类/10.前端性能.md","filePath":"articles/work/面试题分类/10.前端性能.md","lastUpdated":1701168128000}'),t={name:"articles/work/面试题分类/10.前端性能.md"},o=a('<h2 id="前端性能优化" tabindex="-1">前端性能优化 <a class="header-anchor" href="#前端性能优化" aria-label="Permalink to &quot;前端性能优化&quot;">​</a></h2><h2 id="前端常见的性能优化有哪些" tabindex="-1">前端常见的性能优化有哪些？ <a class="header-anchor" href="#前端常见的性能优化有哪些" aria-label="Permalink to &quot;前端常见的性能优化有哪些？&quot;">​</a></h2><p>前端性能优化是为了提高用户体验和页面响应速度的一种手段。以下是一些常见的前端性能优化方法：</p><ol><li>优化图片：对图片进行压缩、使用合适的格式（例如，WebP）和尺寸，以及利用图片懒加载技术。</li><li>使用CDN（内容分发网络）：将静态资源分发到全球各地的服务器，减少用户加载资源的延迟。</li><li>缓存策略：利用浏览器缓存策略，如Cache-Control和ETag，减少重复请求。</li><li>代码压缩与优化：通过压缩和移除不必要的代码，减小文件大小。同时优化代码逻辑，提高代码执行效率。</li><li>异步加载：使用异步加载技术（如，async和defer属性）减少阻塞渲染的脚本。</li><li>利用浏览器渲染优化：避免强制同步布局，减少重排和重绘。</li><li>使用CSS3硬件加速：利用GPU加速，提高动画和页面渲染性能。</li><li>优化CSS选择器：使用简洁、高效的CSS选择器，提高渲染速度。</li><li>代码分割与按需加载：通过代码分割和按需加载技术，降低首次页面加载时间。</li><li>使用Web Workers：利用Web Workers进行后台处理，避免阻塞主线程。</li><li>服务端渲染（SSR）与预渲染：利用服务端渲染和预渲染技术，加快首屏渲染速度。</li><li>优化字体加载：减少字体文件大小，使用字体加载策略避免阻塞渲染。</li><li>使用HTTP/2：使用HTTP/2协议，实现多路复用，降低网络延迟。</li><li>优化资源优先级：利用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 和 <code>&lt;link rel=&quot;prefetch&quot;&gt;</code> 标签，优化资源加载顺序。</li><li>使用事件委托，利用冒泡机制处理事件。</li><li>使用防抖、节流处理频繁触发的事件。</li></ol><p>以上只是一部分常见的前端性能优化方法，实际应用时还需要根据项目具体需求和场景来选择合适的优化策略。</p><h2 id="讲下虚拟列表的原理" tabindex="-1">讲下虚拟列表的原理 <a class="header-anchor" href="#讲下虚拟列表的原理" aria-label="Permalink to &quot;讲下虚拟列表的原理&quot;">​</a></h2><p>虚拟列表（Virtual List）又称无限滚动列表或者长列表优化，是一种前端性能优化技术。其主要目的是在处理大量数据列表时，提高用户体验和页面性能。以下是虚拟列表的基本原理：</p><ol><li>渲染可视区域的列表项：虚拟列表的核心思想是仅渲染可见部分的列表项。当用户滚动列表时，根据可视区域的大小，计算需要显示的列表项，然后只渲染这些列表项。</li><li>列表项的位置计算：虚拟列表需要计算每个列表项的位置信息，以便在滚动过程中正确地显示列表项。这通常通过索引和固定高度（或者预估高度）来实现。</li><li>复用列表项DOM元素：为了减少创建和销毁DOM元素的性能开销，虚拟列表通常会复用列表项的DOM元素。当一个列表项滚出可视区域时，它的DOM元素会被重新利用，用于显示新的列表项。</li><li>占位元素：虚拟列表通常会使用一个占位元素（如一个空的div）来模拟整个列表的高度。这样可以使滚动条保持正确的位置和大小，使用户能够像正常列表一样进行滚动操作。</li><li>事件监听与更新：虚拟列表需要监听滚动事件，以便在用户滚动时实时更新可视区域的列表项。此外，如果列表数据发生变化，虚拟列表还需要重新计算位置信息并更新可视区域的列表项。</li></ol><p>通过上述原理，虚拟列表能够显著减少大量列表项的渲染成本，从而提高页面的性能和用户体验。在实际应用中，根据项目的具体需求和场景，可能还需要对虚拟列表进行一定的定制和优化。</p><h2 id="讲讲常见的性能指标有哪些-它们分别对应的作用是什么" tabindex="-1">讲讲常见的性能指标有哪些？它们分别对应的作用是什么？ <a class="header-anchor" href="#讲讲常见的性能指标有哪些-它们分别对应的作用是什么" aria-label="Permalink to &quot;讲讲常见的性能指标有哪些？它们分别对应的作用是什么？&quot;">​</a></h2><p>Web前端性能指标是衡量一个网站或Web应用程序加载速度、交互性和用户体验的关键因素。以下是一些常见的Web前端性能指标及其解释：</p><ol><li>首次绘制（FP，First Paint）：页面在用户设备上开始渲染的时间点。这个指标可以用来衡量页面加载速度的初步感知。</li><li>首次内容绘制（FCP，First Contentful Paint）：页面上的任何内容（如文字、图片等）首次渲染的时间点。这个指标可以用来衡量用户看到页面内容的速度。</li><li>首次有效绘制（FMP，First Meaningful Paint）：页面主要内容呈现给用户的时间点。这个指标可以用来衡量页面的视觉完整度。</li><li>首次输入延迟（FID，First Input Delay）：用户首次与页面交互（如点击按钮、输入等）所需时间。这个指标可以用来衡量页面的交互性。</li><li>速度指数（SI，Speed Index）：描述页面加载过程中的视觉体验的一个指标。速度指数越低，用户体验越好。</li><li>大致加载时间（TTFB，Time To First Byte）：从用户发出请求到接收到服务器响应的第一个字节所需的时间。这个指标可以用来衡量网络延迟和服务器处理速度。</li><li>页面完全加载时间（Load Time）：从用户发出请求到页面完全加载所需的时间。这个指标可以用来衡量页面加载速度的综合体验。</li><li>页面体积：页面的所有资源（HTML、CSS、JavaScript等）的总大小。页面体积越小，加载速度越快。</li><li>请求次数：加载页面所需的网络请求次数。请求次数越少，加载速度越快。</li><li>首次CPU空闲时间（First CPU Idle）：页面首次达到CPU空闲状态的时间点。这个指标可以用来衡量页面在何时可以响应用户输入。</li><li>最大潜在首次输入延迟（Max Potential FID）：一个预测性指标，衡量在页面首次可交互之前可能发生的最大输入延迟。</li><li>累计布局偏移（CLS，Cumulative Layout Shift）：页面在加载过程中元素位置变化的总和。这个指标可以用来衡量页面的视觉稳定性。</li></ol><hr>',13),r=[o];function n(s,c,d,_,h,p){return l(),e("div",null,r)}const S=i(t,[["render",n]]);export{P as __pageData,S as default};
