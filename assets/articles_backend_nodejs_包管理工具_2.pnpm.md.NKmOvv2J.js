import{_ as e,o as s,c as a,R as i}from"./chunks/framework.ka86hsJC.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/backend/nodejs/包管理工具/2.pnpm.md","filePath":"articles/backend/nodejs/包管理工具/2.pnpm.md","lastUpdated":1701221898000}'),t={name:"articles/backend/nodejs/包管理工具/2.pnpm.md"},o=i('<blockquote><p>新一代包管理工具……</p></blockquote><p>官网：<a href="https://pnpm.io/zh/" target="_blank" rel="noreferrer">Fast, disk space efficient package manager | pnpm</a></p><h2 id="一、入门" tabindex="-1">一、入门 <a class="header-anchor" href="#一、入门" aria-label="Permalink to &quot;一、入门&quot;">​</a></h2><p>当使用 <code>npm</code> 或 <code>Yarn</code> 时，如果你有 100 个项目，并且所有项目都有一个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本。然而，如果是使用 <code>pnpm</code>，依赖包将被 存放在一个统一的位置，因此：</p><ol><li>如果你对同一依赖包需要使用不同的版本，则仅有版本之间不同的文件会被存储起来。例如，如果某个依赖包包含 <code>100</code> 个文件，其发布了一个新 版本，并且新版本中只有一个文件有修改，则 <code>pnpm update</code> 只需要添加一个 新文件到存储中，而不会因为一个文件的修改而保存依赖包的 所有文件。</li><li>所有文件都保存在硬盘上的统一的位置。当安装软件包时， 其包含的所有文件都会==<strong>硬链接</strong>==自此位置，而不会占用 额外的硬盘空间。这让你可以在项目之间方便地共享相同版本的 依赖包。</li></ol><p>最终结果就是以项目和依赖包的比例来看，你节省了大量的硬盘空间， 并且安装速度也大大提高了！</p><p><img src="https://gitlab.com/lijing-2008/blogpic/-/raw/main/pictures/2022/12/17_12_54_42_cafs-illustration-7be6bd97e43ba11a031b099869321deb.jpg" alt="img"></p><h2 id="二、创建非扁平的node-modules" tabindex="-1">二、创建非扁平的<code>node_modules</code> <a class="header-anchor" href="#二、创建非扁平的node-modules" aria-label="Permalink to &quot;二、创建非扁平的`node_modules`&quot;">​</a></h2><p><img src="https://gitlab.com/lijing-2008/blogpic/-/raw/main/pictures/2022/12/17_12_55_50_node-modules-structure-8ab301ddaed3b7530858b233f5b3be57.jpg" alt="img"></p><p>当使用<code>npm</code>或<code>Yarn Classic</code>安装依赖包时，所有软件包都将被提升到<code>node_modules</code>的根目录下。其结果是，源码可以访问本不属于当前项目所设定的依赖包。默认情况下，<code>pnpm</code> 则是通过使用符号链接的方式仅将项目的直接依赖项添加到 <code>node_modules</code> 的根目录下。</p><h2 id="三、存储store" tabindex="-1">三、存储<code>store</code> <a class="header-anchor" href="#三、存储store" aria-label="Permalink to &quot;三、存储`store`&quot;">​</a></h2><p><img src="https://gitlab.com/lijing-2008/blogpic/-/raw/main/pictures/2022/12/17_13_36_54_image-20221217133654044.png" alt="image-20221217133654044"></p><blockquote><p>当安装一个包时，会在<code>pnpm</code>存储库中建立一个硬链接，后序项目使用的时候会根据存储库中的硬链接创建新的硬链接，最终使用的都是磁盘里的同一个文件。</p></blockquote><h3 id="_1-store存储库位置" tabindex="-1">1. <code>store</code>存储库位置 <a class="header-anchor" href="#_1-store存储库位置" aria-label="Permalink to &quot;1. `store`存储库位置&quot;">​</a></h3><p>如果未配置任何存储，则<code>pnpm</code>将在同一硬盘上自动创建一个存储。可以通过命令<code>pnpn store path</code>查看本机的<code>pnpm</code>存储库位置</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> store</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> path</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/Users/lijing/Library/pnpm/store/v3</span></span></code></pre></div><p>可以自定义设置</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> store-dir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /path/to/.pnpm-store</span></span></code></pre></div><h3 id="_2-定期清理store" tabindex="-1">2. 定期清理<code>store</code> <a class="header-anchor" href="#_2-定期清理store" aria-label="Permalink to &quot;2. 定期清理`store`&quot;">​</a></h3><p><code>pnpm </code>存储库的体积会越来越大，随着时间推移有些项目被我删了，但是存储库中依然存在以前的硬链接，如果我们想做清理优化，从store中删除当前未被引用的包来释放store空间，可以执行如下命令：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">➜</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> store</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> prune</span></span></code></pre></div>',21),p=[o];function n(d,l,c,r,h,k){return s(),a("div",null,p)}const b=e(t,[["render",n]]);export{g as __pageData,b as default};
