import{_ as o,o as e,c as i,R as l}from"./chunks/framework.ka86hsJC.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/work/面试题分类/6.浏览器.md","filePath":"articles/work/面试题分类/6.浏览器.md","lastUpdated":1701168128000}'),t={name:"articles/work/面试题分类/6.浏览器.md"},a=l(`<h2 id="浏览器" tabindex="-1">浏览器 <a class="header-anchor" href="#浏览器" aria-label="Permalink to &quot;浏览器&quot;">​</a></h2><h2 id="domcontentloaded-与-load-的区别" tabindex="-1">DOMContentLoaded 与 load 的区别 ? <a class="header-anchor" href="#domcontentloaded-与-load-的区别" aria-label="Permalink to &quot;DOMContentLoaded 与 load 的区别 ?&quot;">​</a></h2><p><code>DOMContentLoaded</code> 和 <code>load</code> 都是浏览器中的事件，它们表示页面加载过程中的不同阶段。这两个事件的主要区别在于它们触发的时间和关注的内容。</p><ol><li><strong>DOMContentLoaded</strong>：当 HTML 文档被完全加载和解析完成后，<code>DOMContentLoaded</code> 事件就会触发，而此时无需等待样式表、图像和子框架的完成加载。换句话说，<code>DOMContentLoaded</code> 主要关注 HTML 文档结构的加载，以便 JavaScript 代码可以在 DOM 树准备就绪后立即运行。这使得你可以尽早地开始操作 DOM，而无需等待其他资源加载完成。</li><li><strong>load</strong>：当页面上的所有资源（包括样式表、图像、子框架等）都完成加载后，<code>load</code> 事件会触发。这意味着在 <code>load</code> 事件触发时，你可以确保页面上的所有资源都可用，这对于需要操作图像尺寸或其他依赖外部资源的功能来说非常有用。</li></ol><p>总之，<code>DOMContentLoaded</code> 和 <code>load</code> 事件的区别在于它们关注的内容和触发时间：</p><ul><li><code>DOMContentLoaded</code>：在 HTML 文档结构加载和解析完成后触发，不等待外部资源（如样式表和图像）加载完成。</li><li><code>load</code>：在页面上的所有资源（包括样式表、图像等）加载完成后触发。</li></ul><p>通常，如果你的 JavaScript 代码仅依赖于 DOM 结构，那么使用 <code>DOMContentLoaded</code> 事件会更快、更有效。如果你的代码依赖于外部资源，那么使用 <code>load</code> 事件可能更合适。</p><h2 id="谈谈你对dom事件机制的理解" tabindex="-1">谈谈你对dom事件机制的理解 <a class="header-anchor" href="#谈谈你对dom事件机制的理解" aria-label="Permalink to &quot;谈谈你对dom事件机制的理解&quot;">​</a></h2><p>DOM（文档对象模型，Document Object Model）事件机制是Web浏览器中实现交互的重要组成部分。在JavaScript中，DOM事件机制使得开发者可以在特定情况下响应用户的操作，如点击、滚动、键盘输入等。以下是对DOM事件机制的一些理解：</p><ol><li>事件流：DOM事件机制分为三个阶段，分别是捕获阶段（capturing phase）、目标阶段（target phase）和冒泡阶段（bubbling phase）。事件首先会经过捕获阶段，沿着DOM树从上至下传递，直到到达事件的目标元素。然后进入目标阶段，触发目标元素上的事件处理程序。最后是冒泡阶段，事件沿着DOM树从下往上回传。</li><li>事件处理程序：开发者可以为DOM元素添加事件处理程序，用以响应特定的事件。事件处理程序可以使用两种方式进行绑定：一种是通过HTML属性直接在元素上绑定，如 <code>onclick</code>；另一种是通过JavaScript为元素添加事件处理程序，如 <code>addEventListener()</code>方法。</li><li>事件对象：当事件触发时，浏览器会自动创建一个事件对象，该对象包含了有关事件的详细信息，例如事件类型、目标元素、触发时间等。事件对象通常作为事件处理程序的第一个参数传递。</li><li>事件委托：事件委托是一种事件处理机制，通过将事件处理程序绑定到父元素，可以实现对子元素的事件监听。这样可以减少事件处理程序的数量，提高性能。事件委托利用了事件冒泡机制，使得在父元素上可以捕捉到子元素触发的事件。</li><li>阻止默认行为和阻止事件传播：在某些情况下，我们希望阻止事件的默认行为或阻止事件的传播。可以通过调用事件对象的 <code>preventDefault()</code>方法来阻止默认行为，调用 <code>stopPropagation()</code>方法来阻止事件的传播。</li></ol><p>了解DOM事件机制对于前端开发者非常重要，因为它涉及到网页交互、用户体验等关键方面。掌握DOM事件机制有助于编写更高效、可维护的代码。</p><h2 id="什么是默认行为-哪些事件有默认行为" tabindex="-1">什么是默认行为，哪些事件有默认行为 <a class="header-anchor" href="#什么是默认行为-哪些事件有默认行为" aria-label="Permalink to &quot;什么是默认行为，哪些事件有默认行为&quot;">​</a></h2><p>默认行为是指浏览器在某些事件触发时自动执行的内置行为。在处理这些事件时，如果不希望触发默认行为，可以使用 <code>preventDefault()</code>方法来阻止它。以下是一些具有默认行为的常见事件：</p><ol><li><code>click</code>：当点击某些元素（如链接）时，浏览器会执行默认行为，如导航到指定的URL。</li><li><code>submit</code>：当表单元素触发提交事件时，浏览器的默认行为是向服务器发送表单数据。</li><li><code>keydown</code>：在输入框内按下某些特定键（如Enter键）时，可能会触发浏览器的默认行为，如提交表单。</li><li><code>contextmenu</code>：当用户右击网页时，浏览器会显示上下文菜单。这是 <code>contextmenu</code>事件的默认行为。</li><li><code>dragstart</code>和 <code>drop</code>：当对某些元素进行拖放操作时，浏览器会执行默认的拖放行为。</li><li><code>mousedown</code>：在文本区域内按下鼠标，浏览器默认会选中文本。</li><li><code>wheel</code>：当用户滚动鼠标滚轮时，浏览器的默认行为是滚动页面。</li><li><code>touchstart</code>、<code>touchmove</code>、<code>touchend</code>：在触摸设备上，这些触摸事件的默认行为可能包括滚动、缩放等。</li></ol><p>这些事件的默认行为取决于浏览器及其版本。在某些情况下，为了实现自定义行为或提高用户体验，开发者可能需要阻止这些默认行为。在事件处理程序中调用 <code>event.preventDefault()</code>方法可以实现这一目的。但请注意，不是所有事件的默认行为都可以被阻止，部分事件可能由于浏览器安全策略等原因无法阻止默认行为。</p><h2 id="css加载会造成阻塞吗" tabindex="-1">CSS加载会造成阻塞吗？ <a class="header-anchor" href="#css加载会造成阻塞吗" aria-label="Permalink to &quot;CSS加载会造成阻塞吗？&quot;">​</a></h2><p>CSS 加载对于渲染流程来说是有阻塞性的。当浏览器遇到一个外部 CSS 文件时，它会发送一个请求去获取这个文件。在获取并解析完 CSS 文件之前，浏览器会阻塞渲染流程。这是因为 CSS 文件中可能包含对页面元素的样式信息，浏览器需要确保在渲染页面时使用正确的样式。</p><p>尽管 CSS 加载阻塞渲染，但它并不阻塞其他资源的下载（如 JavaScript、图片等）。这意味着浏览器可以并行下载其他资源，从而提高页面的加载性能。</p><p>为了避免 CSS 阻塞渲染，可以采取以下措施：</p><ol><li><strong>将 CSS 放在 <code>&lt;head&gt;</code> 标签中</strong>：将 <code>&lt;link&gt;</code> 标签放在 <code>&lt;head&gt;</code> 中，可以确保浏览器尽早发现并下载 CSS 文件，从而减少渲染阻塞的时间。</li><li><strong>使用媒体查询</strong>：通过为 CSS 文件添加媒体查询，可以告诉浏览器只在特定条件下使用这个文件。这样，在不满足条件的情况下，浏览器不会阻塞渲染。例如：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;print.css&quot; media=&quot;print&quot;&gt;</code>。</li><li><strong>代码分割和按需加载</strong>：将 CSS 分为多个较小的文件，只在需要时加载。例如，可以将关键 CSS 内联到 HTML 文档中，以加速首屏渲染。其他非关键 CSS 可以在页面加载完成后异步加载。</li><li><strong>优化和压缩 CSS</strong>：优化和压缩 CSS 代码，可以减小文件大小，从而加快下载速度。可以使用 CSS 预处理器（如 Sass、Less）或压缩工具（如 CSSNano、UglifyCSS）进行优化。</li></ol><p>通过采用这些策略，可以降低 CSS 加载对页面渲染的阻塞性，从而提高用户体验。</p><h2 id="谈谈你对跨域资源共享cors的理解" tabindex="-1">谈谈你对跨域资源共享CORS的理解 <a class="header-anchor" href="#谈谈你对跨域资源共享cors的理解" aria-label="Permalink to &quot;谈谈你对跨域资源共享CORS的理解&quot;">​</a></h2><p>跨域资源共享（Cross-Origin Resource Sharing，简称 CORS）是一种安全机制，允许一个网页的资源（例如 AJAX 请求、字体、图片等）从不同的源（域名、协议或端口）访问。由于同源策略（Same-origin policy）的限制，不同源的网页通常无法互相访问资源。CORS 通过在 HTTP 头中加入特定的字段，使得浏览器和服务器之间可以协商，从而允许跨域请求。</p><p>CORS 主要通过以下几种方式实现跨域访问：</p><ol><li><strong>简单请求</strong>：简单请求是指满足一定条件的跨域请求，包括使用以下 HTTP 方法之一：GET、HEAD、POST，并且 HTTP 头信息不超出以下字段：Accept、Accept-Language、Content-Language、Content-Type（限于 application/x-www-form-urlencoded、multipart/form-data、text/plain）。对于简单请求，浏览器会在请求中添加 <code>Origin</code> 头，指示请求来自哪个源。服务器接收到请求后，如果允许跨域访问，会在响应头中添加 <code>Access-Control-Allow-Origin</code> 字段。</li><li><strong>预检请求</strong>：预检请求（Preflight request）是一种 CORS 机制，用于处理不满足简单请求条件的跨域请求。预检请求使用 OPTIONS 方法发送，浏览器会在请求头中包含 <code>Origin</code>、<code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> 字段。服务器收到预检请求后，如果允许跨域访问，会在响应头中添加 <code>Access-Control-Allow-Origin</code>、<code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code> 等字段。预检请求成功后，浏览器才会发送实际的跨域请求。</li><li><strong>携带身份凭证</strong>：CORS 还支持在跨域请求中携带身份凭证（如 Cookie），通过设置 <code>withCredentials</code> 属性为 <code>true</code>。在这种情况下，服务器需要在响应头中添加 <code>Access-Control-Allow-Credentials: true</code> 字段，以允许携带身份凭证的请求。同时，<code>Access-Control-Allow-Origin</code> 字段不能为通配符（<code>*</code>），必须指定具体的源。</li></ol><p>总的来说，CORS 通过在 HTTP 头中添加特定的字段，使得浏览器和服务器之间可以协商允许跨域访问。这种机制确保了 Web 应用程序的安全性，同时允许跨域资源共享。在实际开发中，服务器端需要正确配置 CORS 相关的响应头，以支持跨域请求。</p><h2 id="浏览器的主要组成部分是什么" tabindex="-1">浏览器的主要组成部分是什么？ <a class="header-anchor" href="#浏览器的主要组成部分是什么" aria-label="Permalink to &quot;浏览器的主要组成部分是什么？&quot;">​</a></h2><p>浏览器主要由以下几个组成部分：</p><ol><li><strong>用户界面（User Interface）</strong>：用户界面包括地址栏、前进/后退按钮、书签菜单等。它是用户与浏览器进行交互的部分。</li><li><strong>浏览器引擎（Browser Engine）</strong>：浏览器引擎是浏览器的核心部分，负责在用户界面和渲染引擎之间协调操作。它接收用户界面的命令，然后将其传递给渲染引擎或其他浏览器组件。</li><li><strong>渲染引擎（Rendering Engine）</strong>：渲染引擎负责显示请求的内容，如 HTML、CSS 和图像等。它将这些资源解析为屏幕上可见的图形。主流的渲染引擎有 WebKit（Chrome、Safari 等浏览器使用）和 Gecko（Firefox 使用）。</li><li><strong>网络（Networking）</strong>：网络组件用于处理网络请求和响应，如 HTTP 请求，以获取所需的资源（HTML、CSS、JavaScript、图像等）。它还负责处理网络协议、DNS 查询等。</li><li><strong>JavaScript 解释器（JavaScript Interpreter）</strong>：JavaScript 解释器负责解析和执行 JavaScript 代码。主流的 JavaScript 引擎有 V8（Chrome 和 Node.js 使用）、SpiderMonkey（Firefox 使用）和 JavaScriptCore（Safari 使用）。</li><li><strong>UI 后端（UI Backend）</strong>：UI 后端负责绘制用户界面的基本组件，如窗口、按钮等。它使用操作系统的用户界面方法，以实现跨平台的用户界面功能。</li><li><strong>数据存储（Data Storage）</strong>：浏览器需要在本地存储数据，如 Cookie、localStorage 和 IndexedDB 等。这些数据存储技术使得 Web 应用可以在浏览器中持久化数据。</li></ol><p>这些组件共同构成了现代浏览器，使得用户可以浏览网页并与之互动。各个浏览器可能在实现上有所不同，但它们的基本组成部分和功能是相似的。</p><h2 id="谈谈你对spa单页应用的理解" tabindex="-1">谈谈你对SPA单页应用的理解 <a class="header-anchor" href="#谈谈你对spa单页应用的理解" aria-label="Permalink to &quot;谈谈你对SPA单页应用的理解&quot;">​</a></h2><p>SPA（Single Page Application，单页应用）是一种 Web 应用开发模式，它在浏览器中加载一个 HTML 文件，然后通过 JavaScript 动态更新和操作 DOM 元素，以实现页面内容的改变。在这种模式下，所有的操作都在同一个页面中进行，不需要跳转到其他页面。这样可以避免多次向服务器请求不同的页面，从而提高用户体验。</p><p>以下是关于 SPA 的一些特点和优缺点：</p><p>优点：</p><ol><li><strong>快速响应</strong>：SPA 在第一次加载时，获取所有必要的资源（HTML、CSS、JavaScript），之后只需通过 AJAX 请求获取数据，无需重新加载整个页面。这使得 SPA 更快速响应，为用户提供了更流畅的体验。</li><li><strong>前后端分离</strong>：SPA 通常与 RESTful API 结合使用，使得前端和后端可以独立开发和部署。这种分离有助于提高开发效率，降低维护成本。</li><li><strong>易于开发和调试</strong>：由于 SPA 主要依赖于 JavaScript 进行页面更新和数据处理，开发者可以使用各种现代 JavaScript 开发工具和框架，如 React、Angular 和 Vue 等，以简化开发和调试过程。</li></ol><p>缺点：</p><ol><li><strong>SEO 问题</strong>：传统的搜索引擎爬虫可能无法正确解析和执行 JavaScript，导致 SPA 页面的内容无法被搜索引擎索引。虽然现代搜索引擎如 Google 在这方面有所改进，但仍需额外的优化以确保 SPA 的搜索引擎优化（SEO）效果。</li><li><strong>初始加载时间</strong>：由于 SPA 在第一次加载时需要获取所有必要的资源，这可能导致初始加载时间较长。为解决这个问题，可以采用代码分割、懒加载等技术来优化加载性能。</li><li><strong>安全问题</strong>：SPA 可能面临跨站脚本（XSS）攻击和其他安全威胁。开发者需要采取相应的安全措施，如对用户输入进行过滤和验证，确保 Web 应用的安全性。</li></ol><p>总的来说，SPA 是一种流行的 Web 应用开发模式，它具有快速响应、前后端分离等优点，但同时也需要注意解决 SEO、性能和安全等方面的问题。</p><h2 id="为什么js执行时会阻塞页面加载" tabindex="-1">为什么JS执行时会阻塞页面加载 <a class="header-anchor" href="#为什么js执行时会阻塞页面加载" aria-label="Permalink to &quot;为什么JS执行时会阻塞页面加载&quot;">​</a></h2><p>JavaScript 执行阻塞页面加载的原因是浏览器在解析和渲染 HTML 文档时遵循自上而下的顺序。当浏览器遇到一个 <code>&lt;script&gt;</code> 标签时（尤其是外部 JavaScript 文件），它会立即下载并执行这个脚本。由于 JavaScript 可能会修改 DOM 结构或操作 CSSOM（如添加、删除元素或更改样式），浏览器必须确保在执行 JavaScript 之前，先解析完 JavaScript 之前的 HTML 和 CSS。这样可以<strong>防止页面出现不一致的渲染效果</strong>。</p><p>因此，当浏览器遇到一个 JavaScript 脚本时，它会：</p><ol><li>阻塞 HTML 解析。</li><li>如果有外部 JavaScript 文件，发送请求并等待下载完成。</li><li>执行 JavaScript 代码。</li><li>继续解析剩余的 HTML 文档。</li></ol><p>JavaScript 执行阻塞页面加载可能会导致性能问题和较差的用户体验。为了解决这个问题，可以采用以下策略：</p><ol><li><strong>将脚本放在文档底部</strong>：将 <code>&lt;script&gt;</code> 标签放在文档的底部，紧邻 <code>&lt;/body&gt;</code> 标签。这样可以确保在执行 JavaScript 之前，先解析完 HTML 和 CSS，从而减少阻塞时间。</li><li><strong>使用 <code>defer</code> 属性</strong>：给 <code>&lt;script&gt;</code> 标签添加 <code>defer</code> 属性，可以告诉浏览器在下载脚本的同时继续解析 HTML。脚本将在文档解析完成后顺序执行。例如：<code>&lt;script src=&quot;example.js&quot; defer&gt;&lt;/script&gt;</code>。</li><li><strong>使用 <code>async</code> 属性</strong>：给 <code>&lt;script&gt;</code> 标签添加 <code>async</code> 属性，可以使脚本异步下载和执行。这意味着脚本会在下载完成后立即执行，而不用等待其他脚本。请注意，这可能会导致脚本执行顺序发生变化，因此只适用于那些不依赖其他脚本的独立脚本。例如：<code>&lt;script src=&quot;example.js&quot; async&gt;&lt;/script&gt;</code>。</li></ol><p>通过采用这些策略，可以减少 JavaScript 对页面加载的阻塞性，提高页面性能和用户体验。</p><h2 id="说一说你对cookie-localstorage-sessionstorage的理解" tabindex="-1">说一说你对Cookie localStorage sessionStorage的理解 <a class="header-anchor" href="#说一说你对cookie-localstorage-sessionstorage的理解" aria-label="Permalink to &quot;说一说你对Cookie localStorage sessionStorage的理解&quot;">​</a></h2><p>Cookie、localStorage 和 sessionStorage 都是在客户端存储数据的技术，但它们之间有一些关键的区别：</p><ol><li><strong>Cookie</strong>： <ul><li>Cookie 最初是为了在客户端保存用户会话信息而设计的，它们可以在客户端和服务器之间进行传递。</li><li>Cookie 的大小限制为 4KB 左右，因此不适合存储大量数据。</li><li>Cookie 有一个有效期，可以设置为特定的时间长度。过期后，Cookie 会被自动删除。</li><li>Cookie 可能面临安全风险，如跨站请求伪造（CSRF）攻击。因此，在使用 Cookie 时需要采取一定的安全措施。</li><li>因为每次 HTTP 请求都会携带 Cookie，所以频繁操作 Cookie 可能会影响性能。</li></ul></li><li><strong>localStorage</strong>： <ul><li>localStorage 是 HTML5 引入的一种客户端存储技术，允许在用户的浏览器中存储较大量的数据（通常为 5-10MB，根据浏览器实现有所不同）。</li><li>localStorage 中存储的数据没有有效期，会一直保留，除非用户手动清除或者使用代码进行删除。</li><li>localStorage 只在客户端进行操作，不会与服务器进行通信。</li><li>localStorage 的数据存储在同一个域名下，不同域名之间的 localStorage 数据是隔离的。</li></ul></li><li><strong>sessionStorage</strong>： <ul><li>sessionStorage 与 localStorage 非常相似，它们都是 HTML5 引入的客户端存储技术，具有相同的存储容量限制。</li><li>与 localStorage 不同的是，sessionStorage 的数据仅在当前浏览器标签或窗口的生命周期内有效。当用户关闭标签或窗口时，sessionStorage 中的数据会被自动清除。</li><li>sessionStorage 同样只在客户端进行操作，不会与服务器进行通信。</li><li>sessionStorage 的数据同样存储在同一个域名下，不同域名之间的 sessionStorage 数据是隔离的。</li></ul></li></ol><p>总之，Cookie、localStorage 和 sessionStorage 都是客户端存储技术，但它们之间在数据有效期、存储容量和与服务器通信等方面有所不同。根据具体需求和场景，开发者可以选择合适的技术进行数据存储。</p><h2 id="讲讲浏览器缓存" tabindex="-1">讲讲浏览器缓存 <a class="header-anchor" href="#讲讲浏览器缓存" aria-label="Permalink to &quot;讲讲浏览器缓存&quot;">​</a></h2><p>浏览器缓存是一种性能优化技术，通过将已请求的资源（如 HTML、CSS、JavaScript、图片等）存储在本地，以减少网络请求和数据传输。当用户再次访问相同的资源时，浏览器可以直接从缓存中获取，从而加快页面加载速度、降低服务器压力和减少网络流量消耗。</p><p>浏览器缓存主要分为以下几种类型：</p><ol><li><strong>强缓存</strong>： 强缓存是指浏览器在缓存期间内不会再向服务器发送任何请求，而是直接从本地缓存中获取资源。强缓存由以下两个 HTTP 响应头控制： <ul><li><code>Expires</code>：指定资源的过期时间。例如：<code>Expires: Wed, 21 Oct 2023 07:28:00 GMT</code>。但由于服务器时间和客户端时间可能存在差异，所以这个响应头不太准确。</li><li><code>Cache-Control</code>：使用更现代且准确的方式控制缓存。例如：<code>Cache-Control: max-age=3600</code>，表示资源的缓存有效期为 3600 秒。其他可用的指令还包括 <code>no-cache</code>、<code>no-store</code>、<code>must-revalidate</code> 等。</li></ul></li><li><strong>协商缓存</strong>： 当强缓存失效后，浏览器会向服务器发送请求，以验证资源是否有更新。协商缓存通过以下 HTTP 响应头和请求头控制： <ul><li><code>Last-Modified</code> 和 <code>If-Modified-Since</code>：服务器返回资源时，通过 <code>Last-Modified</code> 响应头指定资源最后修改时间。浏览器下次请求时会通过 <code>If-Modified-Since</code> 请求头发送这个时间。服务器会比较这个时间和资源的实际修改时间，如果没有变化，则返回 <code>304 Not Modified</code> 状态码，浏览器将使用本地缓存；否则返回更新后的资源和新的 <code>Last-Modified</code> 时间。</li><li><code>ETag</code> 和 <code>If-None-Match</code>：<code>ETag</code> 是服务器为资源生成的唯一标识（通常是哈希值）。浏览器下次请求时会通过 <code>If-None-Match</code> 请求头发送这个标识。服务器会比较这个标识和资源的当前 <code>ETag</code>，如果相同，则返回 <code>304 Not Modified</code> 状态码；否则返回更新后的资源和新的 <code>ETag</code>。</li></ul></li><li><strong>其他缓存技术</strong>： 除了上述浏览器缓存机制外，还有一些其他缓存技术，如 Service Workers、Memory Cache、IndexedDB 等。它们可以根据具体需求和场景进行灵活地缓存策略配置。</li></ol><h2 id="路由history和hash的区别" tabindex="-1">路由history和hash的区别？ <a class="header-anchor" href="#路由history和hash的区别" aria-label="Permalink to &quot;路由history和hash的区别？&quot;">​</a></h2><p>路由 history 和 hash 是前端路由（Single Page Application, SPA）中常用的两种模式。它们的主要区别在于实现方式和 URL 的展示形式。</p><ol><li><strong>Hash 模式</strong>： <ul><li>Hash 模式基于浏览器 URL 中的哈希（<code>#</code>）部分进行路由切换。当哈希值改变时，浏览器不会向服务器发送请求，而是触发 <code>hashchange</code> 事件。前端路由库会监听这个事件，并根据哈希值变化来更新视图。</li><li>URL 示例：<code>https://example.com/#/page1</code></li><li>Hash 模式兼容性较好，适用于旧版本浏览器。</li></ul></li><li><strong>History 模式</strong>： <ul><li>History 模式基于 HTML5 的 History API（如 <code>pushState</code>、<code>replaceState</code> 和 <code>popstate</code> 事件）实现。这些 API 允许在不重新加载页面的情况下，直接操作浏览器的历史记录和 URL。</li><li>URL 示例：<code>https://example.com/page1</code></li><li>History 模式需要服务器的配合，因为在用户直接访问某个路由（如 <code>https://example.com/page1</code>）时，如果服务器没有对应的配置，可能会返回 404 错误。为了解决这个问题，服务器需要设置一个通配符路由，将所有未匹配到的路由都重定向到单页应用的入口 HTML 文件。</li></ul></li></ol><p>总之，Hash 模式和 History 模式是前端路由中的两种实现方式，具有不同的 URL 展示形式和浏览器兼容性。在选择路由模式时，需要根据项目需求、用户体验和服务器配置等因素进行权衡。</p><h2 id="谈一谈你对重排和重绘理解" tabindex="-1">谈一谈你对重排和重绘理解 <a class="header-anchor" href="#谈一谈你对重排和重绘理解" aria-label="Permalink to &quot;谈一谈你对重排和重绘理解&quot;">​</a></h2><p>在浏览器渲染过程中，重排（reflow）和重绘（repaint）是两个重要概念。它们是指浏览器在处理 DOM 元素样式和位置变化时所发生的操作。</p><p><strong>重排（Reflow）</strong>： 重排，也称为回流，是指浏览器重新计算元素的布局、尺寸和位置等几何信息的过程。当 DOM 结构发生变化，或者元素的尺寸、位置、边距等样式发生改变时，浏览器需要重新计算这些元素的几何属性，并确定如何在页面上显示它们。重排可能会导致整个页面的重新布局，因此是一个性能敏感的过程。</p><p>触发重排的操作包括：</p><ul><li>添加或删除 DOM 元素</li><li>修改元素尺寸（如宽度、高度、边距等）</li><li>修改元素位置（如浮动、定位等）</li><li>改变窗口大小</li><li>修改默认字体大小</li></ul><p><strong>重绘（Repaint）</strong>： 重绘是指浏览器重新绘制 DOM 元素的过程，但不涉及元素的几何属性计算。当元素的外观样式（如颜色、背景、边框等）发生变化时，浏览器需要重新绘制这些元素，以反映样式的变化。相较于重排，重绘的性能开销较小。</p><p>触发重绘的操作包括：</p><ul><li>修改元素颜色、背景等视觉样式</li><li>元素的几何属性发生变化，触发重排（重排会导致重绘）</li></ul><p>为了提高页面渲染性能，我们应尽量减少重排和重绘的发生。一些优化措施包括：</p><ul><li>避免频繁修改 DOM 结构和样式，可以将修改操作合并后一次性执行</li><li>使用 <code>requestAnimationFrame</code> 或者 <code>setTimeout</code> 函数进行样式更新的节流</li><li>对于不可见或者离屏的元素，可以先将它们移除或隐藏，然后在内存中进行样式修改，最后再重新插入或显示</li><li>使用 CSS3 动画替代 JavaScript 动画，以利用 GPU 加速</li><li>使用虚拟 DOM 技术（如 React、Vue 等框架），避免不必要的 DOM 更新</li></ul><h2 id="谈一谈跨域-同源策略-以及跨域解决方案" tabindex="-1">谈一谈跨域，同源策略，以及跨域解决方案 <a class="header-anchor" href="#谈一谈跨域-同源策略-以及跨域解决方案" aria-label="Permalink to &quot;谈一谈跨域，同源策略，以及跨域解决方案&quot;">​</a></h2><p><strong>同源策略</strong>： 同源策略是一种安全机制，用于限制文档或脚本从不同来源的数据进行交互。当两个资源具有相同的协议（如 http 或 https）、域名和端口时，它们被认为是同源的。同源策略限制了从一个源加载的网页脚本与来自另一个源的资源进行交互的能力，以防止恶意行为，如跨站脚本攻击（XSS）或数据窃取。</p><p><strong>跨域</strong>： 跨域是指当一个资源试图访问来自不同源的另一个资源时，由于同源策略的限制而无法进行的情况。例如，一个从 <code>http://example-a.com</code> 加载的网页试图通过 AJAX 请求 <code>http://example-b.com</code> 上的数据，这就是一个跨域请求。</p><p><strong>跨域解决方案</strong>： 有多种方法可以绕过同源策略的限制，实现跨域请求。以下是一些常见的跨域解决方案：</p><ol><li><strong>CORS（跨域资源共享）</strong>： CORS 是一种官方推荐的跨域解决方案。它允许服务器通过设置响应头（如 <code>Access-Control-Allow-Origin</code>）来放宽对跨域请求的限制。浏览器将根据这些响应头决定是否允许跨域请求。</li><li><strong>JSONP（JSON with Padding）</strong>： JSONP 利用了 <code>&lt;script&gt;</code> 标签的 src 属性不受同源策略限制的特性。它通过动态创建一个 <code>&lt;script&gt;</code> 标签，并将回调函数作为参数传递给服务器。服务器将请求数据包装在回调函数中，并将其作为响应返回。客户端脚本收到响应后，会立即执行回调函数以获取数据。</li><li><strong>使用代理服务器</strong>： 可以通过代理服务器将跨域请求转发到目标服务器。这样，客户端与代理服务器之间的请求就是同源的，而代理服务器与目标服务器之间的请求则由代理服务器完成。常见的代理服务器实现方式有 Nginx 反向代理、Node.js 中间件代理等。</li><li><strong>使用 iframe 和 postMessage</strong>： 可以使用 iframe 加载跨域页面，然后通过 <code>window.postMessage</code> 方法在不同源的窗口之间传递消息。这种方法需要跨域页面的配合，以便在接收到消息时执行相应操作。</li><li><strong>使用 WebSockets</strong>： WebSockets 可以实现跨域通信，因为它们不受同源策略限制。通过建立一个 WebSocket 连接，客户端和服务器可以进行双向通信，实现跨域数据交换。</li><li><strong>使用 CORS 代理</strong>： 如果目标服务器没有实现 CORS，而你又不想在自己的服务器上设置反向代理，可以使用第三方 CORS 代理服务。这些服务在请求目标服务器时为你添加 CORS 响应头，从而使浏览器允许跨域请求。但请注意，这可能会带来安全风险，因此不建议在生产环境中使用。</li><li><strong>使用 document.domain</strong>： 当两个具有相同根域名但子域名不同的页面需要进行跨域通信时，可以将它们的 <code>document.domain</code> 设置为相同的值。这样，它们将被视为同源，可以进行通信。但此方法仅适用于具有相同根域名的情况。</li><li><strong>使用 window.name</strong>： 可以利用 <code>window.name</code> 在同源和跨域的窗口之间传递数据。<code>window.name</code> 属性在窗口跳转时会保留其值，因此可以将数据存储在 <code>window.name</code> 中，然后通过跳转到同源页面来读取数据。但这种方法受到一些限制，只能传递字符串数据，且安全性和可靠性相对较低。</li></ol><p>每种跨域解决方案都有其优缺点，需要根据实际场景和需求选择合适的方法。现代 Web 开发中，CORS 是最常用且推荐的解决方案。但在某些特殊场景或者兼容旧版浏览器时，可能需要考虑其他方案。在实现跨域时，始终要关注安全性和数据保护，确保不会引入安全漏洞。</p><h2 id="前端如何进行seo优化" tabindex="-1">前端如何进行seo优化 <a class="header-anchor" href="#前端如何进行seo优化" aria-label="Permalink to &quot;前端如何进行seo优化&quot;">​</a></h2><p>前端在进行搜索引擎优化（SEO）时，可以从以下几个方面进行优化：</p><ol><li><strong>合理的标题、描述和关键词</strong>： 确保每个页面都有独特且描述准确的 <code>&lt;title&gt;</code>标签和 <code>&lt;meta name=&quot;description&quot;&gt;</code>标签。这有助于搜索引擎理解页面内容，同时也为用户在搜索结果中显示更具吸引力的信息。</li><li><strong>语义化的 HTML 结构</strong>： 使用语义化的 HTML 标签，如 <code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>等，以帮助搜索引擎更好地理解页面结构和内容。</li><li><strong>良好的页面结构</strong>： 确保页面具有清晰的层次结构和导航，这有助于搜索引擎爬虫更容易地抓取和索引页面内容。</li><li><strong>优化 URL 结构</strong>： 使用简洁且描述性的 URL，避免过长或包含不必要的参数。这有助于搜索引擎理解页面内容，并提高用户体验。</li><li><strong>使用 header 标签</strong>： 使用 <code>&lt;h1&gt;</code>至 <code>&lt;h6&gt;</code>等 header 标签来组织页面内容，确保每个页面只有一个 <code>&lt;h1&gt;</code>标签。这有助于搜索引擎理解页面的主题和重要性。</li><li><strong>图片优化</strong>： 为所有图片添加 <code>alt</code>属性，以便搜索引擎了解图片内容。同时，优化图片大小和格式，以提高页面加载速度。</li><li><strong>内部链接和锚文本</strong>： 合理地使用内部链接和有意义的锚文本，以帮助搜索引擎更好地理解站点结构和内容之间的关联。</li><li><strong>响应式设计</strong>： 确保网站适应不同设备和屏幕尺寸，提供良好的用户体验。搜索引擎倾向于对移动友好的网站给予更高的排名。</li><li><strong>网站速度优化</strong>： 提高网站加载速度，减少页面渲染时间。这包括压缩资源、合并文件、优化图片、使用浏览器缓存等。搜索引擎会考虑网站速度作为排名的因素之一。</li><li><strong>遵循 W3C 标准</strong>： 确保代码符合 W3C 标准，减少 HTML、CSS 和 JavaScript 的错误。这有助于搜索引擎更容易地抓取和解析页面内容。</li><li><strong>生成 XML Sitemap</strong>： 为网站创建一个 XML Sitemap，并提交给搜索引擎。这有助于搜索引擎更有效地抓取和索引网站内容。</li><li><strong>使用结构化数据</strong>： 使用结构化数据（如 Schema.org、JSON-LD、Microdata 等）来标注页面内容，有助于搜索引擎更准确地理解页面信息，并可能在搜索结果中显示为富文本摘要，提高点击率。</li><li><strong>使用 robots.txt 控制爬虫访问</strong>： 合理设置 robots.txt 文件，指定搜索引擎爬虫可以访问和抓取的页面，避免爬虫抓取不相关或低质量的页面。</li><li><strong>优化站内搜索</strong>： 提供高效、准确的站内搜索功能，有助于提高用户体验和用户停留时间，间接影响搜索排名。</li><li><strong>社交媒体整合</strong>： 将网站内容与社交媒体平台整合，提高内容的曝光度和分享率，增加外部链接，有助于提高搜索排名。</li><li><strong>网站安全</strong>： 使用 HTTPS 加密，保护用户数据和隐私。搜索引擎会将安全性作为排名因素之一。</li></ol><p>总之，前端在进行 SEO 优化时，要关注页面结构、内容、用户体验和技术实现等多个方面。通过提高页面质量、提升用户体验和遵循搜索引擎的最佳实践，有助于提高网站在搜索结果中的排名和可见度。</p><h2 id="requestanimationframe与requestidlecallback区别" tabindex="-1">requestAnimationFrame与requestIdleCallback区别 <a class="header-anchor" href="#requestanimationframe与requestidlecallback区别" aria-label="Permalink to &quot;requestAnimationFrame与requestIdleCallback区别&quot;">​</a></h2><p><code>requestAnimationFrame</code>和 <code>requestIdleCallback</code>都是浏览器提供的用于优化JavaScript任务调度的API。它们之间的主要区别在于它们的使用场景和触发时机。</p><ol><li><strong>requestAnimationFrame</strong>：</li></ol><p><code>requestAnimationFrame</code>主要用于优化浏览器的动画渲染。它允许你在浏览器即将进行下一次重绘之前安排一个回调函数执行。这意味着，回调函数将在最佳的时间点执行，从而提高动画的性能和流畅度。</p><p><code>requestAnimationFrame</code>的优点包括：</p><ul><li>与浏览器的刷新率同步，避免动画卡顿或丢帧现象。</li><li>当页面不可见或最小化时，浏览器会暂停执行 <code>requestAnimationFrame</code>回调，从而减少CPU和GPU的使用，节省资源。</li></ul><p>典型的 <code>requestAnimationFrame</code>用法如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 执行动画操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在下一次重绘之前请求执行动画</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animate);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animate);</span></span></code></pre></div><ol><li><strong>requestIdleCallback</strong>：</li></ol><p><code>requestIdleCallback</code>用于优化非关键性任务的执行，例如代码分析、日志报告、数据存储等。当浏览器空闲时，<code>requestIdleCallback</code>会触发回调函数执行，从而避免阻塞关键任务，如渲染、动画和用户交互。</p><p><code>requestIdleCallback</code>的优点包括：</p><ul><li>利用浏览器的空闲时间执行低优先级任务，避免干扰关键任务。</li><li>可以设置超时时间，确保在指定时间内完成任务。</li></ul><p>典型的 <code>requestIdleCallback</code>用法如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> performNonCriticalTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">deadline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (deadline.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timeRemaining</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 执行非关键任务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果还有未完成的任务，继续请求空闲回调</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  requestIdleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(performNonCriticalTask);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestIdleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(performNonCriticalTask);</span></span></code></pre></div><p>总之，<code>requestAnimationFrame</code>和 <code>requestIdleCallback</code>分别用于优化动画渲染和非关键性任务的执行。<code>requestAnimationFrame</code>在每次浏览器重绘之前执行回调，以实现高性能的动画效果；<code>requestIdleCallback</code>则在浏览器空闲时执行回调，避免影响关键任务。</p><h2 id="ssr的实现原理" tabindex="-1">SSR的实现原理？ <a class="header-anchor" href="#ssr的实现原理" aria-label="Permalink to &quot;SSR的实现原理？&quot;">​</a></h2><p>服务器端渲染（Server Side Rendering，简称 SSR）是一种 web 应用的渲染方式，其实现原理是在服务器端将页面内容渲染为 HTML 字符串，然后将这些字符串发送到客户端，客户端接收到 HTML 后直接显示，无需等待 JavaScript 的解析、执行和渲染。</p><p>SSR 的核心实现原理可以概括为以下几个步骤：</p><ol><li><strong>请求处理</strong>：客户端发起请求时，请求首先到达服务器。</li><li><strong>服务器渲染</strong>：服务器接收到请求后，根据路由和数据，将对应的页面内容渲染为 HTML 字符串。这一步通常涉及到模板引擎或服务器端 JavaScript 框架的使用，例如 React 的 <code>ReactDOMServer.renderToString()</code> 和 Vue 的 <code>vue-server-renderer</code>。</li><li><strong>数据注入</strong>：在渲染过程中，服务器还需要获取所需的数据，将其注入到 HTML 中。这可以通过内联脚本、JSON 格式或其他方式实现。数据注入的目的是在客户端 JavaScript 代码运行时能够获取到服务器端已经准备好的数据，避免重复请求。</li><li><strong>生成完整 HTML</strong>：将渲染好的 HTML 字符串插入到 HTML 模板中，形成一个完整的 HTML 页面。这个页面包含了已经渲染好的内容以及必要的 JavaScript、CSS 等资源引用。</li><li><strong>发送响应</strong>：服务器将完整的 HTML 页面作为响应发送给客户端。客户端接收到响应后，直接将 HTML 页面展示给用户。</li><li><strong>客户端接管</strong>：在客户端，浏览器会解析和执行 JavaScript 代码，接管页面的交互和操作。这一步通常被称为 &quot;hydration&quot; 或 &quot;激活&quot;，因为客户端 JavaScript 代码需要 &quot;激活&quot; 服务器端渲染的静态 HTML，使其具有动态功能。</li></ol><p>通过 SSR，用户可以更快地看到页面的内容，因为无需等待客户端的 JavaScript 代码下载、解析、执行和渲染。此外，由于搜索引擎爬虫能够更好地解析服务器端渲染的 HTML，因此 SSR 对 SEO 也有一定的优势。然而，SSR 也会增加服务器的负担，因为服务器需要负责渲染页面。在实际应用中，可以根据项目需求和性能要求，选择合适的渲染方式。</p><h2 id="讲讲你对pwa的理解" tabindex="-1">讲讲你对PWA的理解 <a class="header-anchor" href="#讲讲你对pwa的理解" aria-label="Permalink to &quot;讲讲你对PWA的理解&quot;">​</a></h2><p>PWA（Progressive Web App，渐进式 web 应用）是一种将现代 web 技术与传统移动应用功能结合的应用开发模式。PWA 旨在通过提供原生应用的类似体验，改进 web 应用的可用性、性能和用户体验。PWA 的核心技术包括 Service Workers、Web App Manifest 和离线缓存等。</p><p>PWA 的主要特点如下：</p><ol><li><strong>可靠性</strong>：通过 Service Workers 和离线缓存技术，PWA 可以在无网络或网络不稳定的环境下运行。用户在访问 PWA 时，即使断网，也能看到离线内容或自定义的离线提示页面。</li><li><strong>快速</strong>：PWA 通过预缓存关键资源和优化加载策略，提高了应用的加载速度和运行性能。在访问 PWA 时，用户可以更快地看到页面内容，并感受到流畅的交互体验。</li><li><strong>可安装</strong>：通过 Web App Manifest，PWA 可以被添加到用户的设备主屏幕，并以独立窗口运行，类似于原生应用。用户可以直接从主屏幕启动 PWA，而无需通过浏览器。</li><li><strong>跨平台</strong>：PWA 基于 web 技术，因此可以在不同的操作系统和设备上运行，包括桌面和移动设备。这意味着，开发者只需维护一套代码，就能为多个平台提供类似的应用体验。</li><li><strong>更新简便</strong>：PWA 无需通过应用商店发布和更新。当用户访问 PWA 时，应用会自动检查并应用更新。这样，用户总是能获取到最新的应用版本，而开发者也能更轻松地发布和管理更新。</li><li><strong>安全</strong>：PWA 需要通过 HTTPS 运行，确保数据传输的安全性。同时，由于 Service Workers 可以拦截和处理请求，PWA 还可以实现更丰富的安全策略和功能，如请求过滤、内容安全策略（CSP）等。</li><li><strong>可搜索</strong>：PWA 作为 web 应用，可以被搜索引擎抓取和索引。这意味着，PWA 可以获得更好的搜索引擎优化（SEO），提高应用的可见度和用户获取途径。</li></ol><p>总之，PWA 是一种充分利用现代 web 技术，为用户提供原生应用般体验的 web 应用开发模式。通过 PWA，开发者可以实现更可靠、快速、可安装和跨平台的应用，提升用户体验和满意度。</p><h2 id="谈谈浏览器的离线缓存与本地缓存的区别" tabindex="-1">谈谈浏览器的离线缓存与本地缓存的区别 <a class="header-anchor" href="#谈谈浏览器的离线缓存与本地缓存的区别" aria-label="Permalink to &quot;谈谈浏览器的离线缓存与本地缓存的区别&quot;">​</a></h2><p>浏览器的离线缓存和本地缓存都是用于在用户设备上存储数据以提高网页性能的技术，但它们的实现方式和使用场景略有不同。下面是它们之间的一些主要区别：</p><ol><li>目的：</li></ol><p>离线缓存：主要用于在用户离线时仍然可以访问网页。它可以在没有网络连接的情况下提供基本的功能，如查看已缓存页面的内容。</p><p>本地缓存：主要用于减少网络延迟，提高加载速度。通过在用户设备上缓存常用资源，如图片、脚本、样式等，可以在用户再次访问网站时直接从缓存中读取，降低服务器负担和提高用户体验。</p><ol start="2"><li>存储类型：</li></ol><p>离线缓存：使用HTML5的Application Cache（AppCache）和Service Worker技术实现。这些技术允许开发者为用户设备创建一个离线版本的网页，包括HTML、CSS、JavaScript等资源。</p><p>本地缓存：使用浏览器提供的缓存策略和存储机制实现，如HTTP缓存、Cookie、Web Storage（包括localStorage和sessionStorage）和IndexedDB等。</p><ol start="3"><li>生命周期：</li></ol><p>离线缓存：由开发者通过AppCache或Service Worker配置文件控制，包括缓存资源的更新和过期策略。</p><p>本地缓存：由浏览器或服务器通过HTTP头部字段（如Cache-Control、Expires等）控制，或通过脚本（如localStorage和IndexedDB）设置的存储时间限制。</p><ol start="4"><li>适用场景：</li></ol><p>离线缓存：适用于需要在无网络环境下访问的网页，例如离线阅读应用、PWA（Progressive Web Apps）等。</p><p>本地缓存：适用于任何需要提高网站性能和加载速度的场景，减少不必要的网络请求。</p><p>总之，离线缓存和本地缓存都是为了优化网页性能，它们各自针对不同的使用场景。离线缓存主要是为了在没有网络连接时继续访问网页，而本地缓存则是为了提高网页加载速度和降低服务器负担。</p><h2 id="谈谈你对shadow-dom的理解" tabindex="-1">谈谈你对Shadow DOM的理解 <a class="header-anchor" href="#谈谈你对shadow-dom的理解" aria-label="Permalink to &quot;谈谈你对Shadow DOM的理解&quot;">​</a></h2><p>Shadow DOM 是 Web Components 规范的一个重要组成部分，它提供了一种将 HTML、CSS 和 JavaScript 封装在独立、隔离的 DOM 结构中的方法，从而实现组件的样式和行为的封装。Shadow DOM 解决了全局样式污染的问题，使得开发者可以创建具有独立样式和逻辑的可重用组件。</p><p>Shadow DOM 的关键特点如下：</p><ol><li><strong>封装</strong>：Shadow DOM 允许将一组 DOM 元素和相关样式封装在一个独立的、隔离的 DOM 树中。这样，组件的样式不会影响到主文档，同样主文档的样式也不会影响到组件。通过这种封装，组件可以在不同的应用中重用，而无需担心样式污染和冲突。</li><li><strong>隔离</strong>：Shadow DOM 的树结构是隔离的，意味着组件内的 DOM 元素和 JavaScript 逻辑与主文档是分开的。这有助于保护组件内的数据和方法，避免被外部访问和修改。</li><li><strong>附件阴影树</strong>：通过 <code>attachShadow</code> 方法，可以在一个普通的 DOM 元素上创建一个 Shadow DOM。这个普通元素被称为 &quot;Shadow Host&quot;，而创建的 Shadow DOM 被称为 &quot;Shadow Tree&quot;。Shadow Tree 与主文档的 DOM 树是并列的，互不干扰。</li><li><strong>插槽（Slot）</strong>：Shadow DOM 支持使用 <code>&lt;slot&gt;</code> 元素来分发（或投影）主文档中的内容。这使得组件可以定义可自定义的内容区域，让使用者在引入组件时提供所需的内容。</li><li><strong>样式隔离</strong>：组件内的 CSS 样式只对 Shadow Tree 中的元素生效，不会影响到主文档。同时，主文档的 CSS 样式（除了 CSS 变量）也不会影响到组件。这样，组件的样式能够完全独立，避免了全局样式污染。</li></ol><p>总之，Shadow DOM 提供了一种在 Web 开发中实现组件封装和样式隔离的机制。通过使用 Shadow DOM，开发者可以创建具有独立样式和行为的可重用组件，简化开发过程，提高组件的可维护性。</p><h2 id="谈谈你对微前端的理解" tabindex="-1">谈谈你对微前端的理解？ <a class="header-anchor" href="#谈谈你对微前端的理解" aria-label="Permalink to &quot;谈谈你对微前端的理解？&quot;">​</a></h2><p>微前端（Micro Frontends）是一种架构模式，它的主要目标是将单一的，通常较大的前端应用程序（如单页面应用）拆分为多个较小的、独立的部分。这些独立的部分通常被称为&quot;微应用&quot;（micro apps）。</p><p>微前端的主要理念来源于微服务架构，后者在后端开发中已经变得非常流行。与微服务一样，微前端也强调团队的独立性和技术栈的多样性。每个微应用可以由不同的团队使用不同的技术栈来开发，然后再集成到一个统一的用户界面中。</p><p>以下是我对微前端的一些理解：</p><ol><li><strong>解耦</strong>：微前端的一个关键优点是解耦。每个微应用都是独立的，有自己的代码库、构建流程、开发团队和生命周期。这可以使每个团队更专注于自己的部分，降低开发复杂性，提高开发速度。</li><li><strong>技术栈无关</strong>：每个微应用可以选择适合自己需求的技术栈，不必受限于整个应用的技术选择。这使得前端开发可以跟上技术的发展，逐步引入新的技术和工具，而无需进行大规模的重构。</li><li><strong>并行开发</strong>：由于每个微应用都是独立的，所以可以并行开发，提高开发效率。也可以更灵活地调整开发资源和计划，因为每个团队的工作不会直接影响到其他团队。</li><li><strong>独立部署</strong>：每个微应用可以独立部署，不需要重新部署整个应用。这可以大大减少部署带来的风险，并且可以更快地将新功能和修复推送到用户那里。</li></ol><p>但是，微前端也不是没有挑战的。例如，微应用间的通信和协调、整体用户体验的一致性、性能问题（比如加载时间和资源占用）等，都需要在实施微前端架构时仔细考虑。</p><p>总的来说，我认为微前端是一个有前景的架构模式，它在前端开发中引入了微服务的思想，有助于解决大型、复杂的前端应用开发和维护的问题。但是，它也需要对前端架构和工程化有深入的理解，才能有效地实施和管理。</p><h2 id="讲讲浏览器的进程和线程" tabindex="-1">讲讲浏览器的进程和线程 <a class="header-anchor" href="#讲讲浏览器的进程和线程" aria-label="Permalink to &quot;讲讲浏览器的进程和线程&quot;">​</a></h2><p>浏览器的进程和线程是浏览器实现其功能的基础。它们之间的关系和任务分工对于理解浏览器的运行原理和性能优化至关重要。简单来说，进程是操作系统资源分配的最小单位，而线程是操作系统调度（CPU 利用率）的最小单位。</p><p><strong>进程</strong>：</p><p>进程是一个运行中的程序实例，它包含程序所需的所有资源。一个进程拥有独立的内存空间、全局变量、打开的文件和设备等。浏览器中的进程主要有以下几类：</p><ol><li><strong>浏览器主进程</strong>：负责协调浏览器的各个模块，包括用户界面、地址栏、书签栏等。它还负责管理浏览器的各个标签页进程和插件进程。</li><li><strong>渲染进程</strong>：负责将网页内容渲染到屏幕上。每个标签页通常对应一个渲染进程（在某些情况下，标签页可能会共享一个渲染进程）。渲染进程包括 HTML、CSS 和 JavaScript 的解析、布局、渲染以及执行等任务。</li><li><strong>插件进程</strong>：负责运行和管理浏览器插件（如 Flash）。</li><li><strong>网络进程</strong>：负责处理网络请求，包括资源的下载、上传和缓存。</li></ol><p><strong>线程</strong>：</p><p>线程是进程中的一个执行单元，它共享进程的资源，如内存空间和文件句柄。一个进程可以有多个线程，这些线程可以并发执行任务。在浏览器中，有以下几种主要的线程：</p><ol><li><strong>主线程</strong>：渲染进程的主要执行线程，负责解析和执行 JavaScript 代码、处理 DOM 事件、执行 CSS 动画等任务。主线程是单线程的，这意味着 JavaScript 的执行和页面渲染任务需要排队执行。</li><li><strong>Web Workers</strong>：一种可以在后台运行 JavaScript 代码的线程，它与主线程独立，不会阻塞主线程。Web Workers 可以用于执行耗时的计算任务，避免影响页面渲染。</li><li><strong>Service Workers</strong>：用于实现离线缓存、消息推送、后台同步等功能的独立线程。Service Workers 与 Web Workers 类似，但具有更多的 API 和能力。</li><li><strong>渲染线程</strong>：负责将解析好的 HTML、CSS 和图像资源绘制到屏幕上。渲染线程与主线程是分离的，这意味着页面的渲染和 JavaScript 的执行是并行进行的。</li><li><strong>合成线程</strong>：负责处理页面的合成和分层。当浏览器检测到可以使用 GPU 加速的动画时，合成线程会将这些动画分离出来并在 GPU 上独立运行。这可以避免主线程的阻塞，提高页面的性能。</li><li><strong>网络线程</strong>：负责处理 HTTP 请求和响应，以及与服务器之间的通信。网络线程与主线程独立，以避免网络请求导致的阻塞。</li><li><strong>定时器线程</strong>：负责处理 JavaScript 中的定时器任务（如 <code>setTimeout</code> 和 <code>setInterval</code>）。这些任务会在定时器线程上排队执行，然后在指定的时间后将回调函数推送到主线程的任务队列中。</li><li><strong>解析线程</strong>：负责解析 HTML 和 CSS。解析线程会将解析后的 DOM 树和 CSSOM 树合并为渲染树，并传递给渲染线程进行绘制。在某些情况下，解析线程和主线程可能会合并为一个线程，这取决于浏览器的具体实现。</li><li><strong>文件线程</strong>：负责处理与文件系统的交互，如读取和写入操作。这些操作在文件线程上执行，避免阻塞主线程。</li></ol><p>以上就是浏览器中的一些主要进程和线程。需要注意的是，不同浏览器的实现可能会有所不同，但它们的基本原理和任务分工是类似的。理解这些进程和线程之间的关系有助于我们更好地理解浏览器的运行原理，从而优化前端性能。</p><h2 id="html解析过程" tabindex="-1">html解析过程 <a class="header-anchor" href="#html解析过程" aria-label="Permalink to &quot;html解析过程&quot;">​</a></h2><p>HTML（超文本标记语言）是用于构建和呈现网页内容的标准标记语言。浏览器解析HTML的过程包括以下几个步骤：</p><ol><li>获取HTML文档：浏览器首先向服务器发送请求，获取HTML文档。服务器响应请求并返回HTML文件，通常是一个以 <code>.html</code>或 <code>.htm</code>为扩展名的文件。</li><li>词法分析：浏览器开始对HTML文档进行词法分析，将其分解成各种符号（tokens），例如标签、属性和文本内容。词法分析的结果是一系列token，这些token有助于构建DOM树。</li><li>构建DOM树：浏览器将词法分析得到的tokens用于构建DOM（文档对象模型）树。DOM树是一种表示HTML文档结构的树形数据结构，其中每个节点代表页面上的一个元素、属性或文本内容。</li><li>解析CSS：浏览器会解析与HTML文档关联的CSS样式表，包括内联样式、内部样式和外部样式。解析CSS样式后，浏览器会生成CSSOM（CSS对象模型）树，这是一种表示CSS样式的树形结构。</li><li>构建渲染树：浏览器将DOM树和CSSOM树合并，生成渲染树。渲染树包含了页面上可见的所有元素及其样式信息。隐藏元素（如 <code>display: none;</code>）不会包含在渲染树中。</li><li>布局（Layout）：根据渲染树，浏览器计算每个元素在页面上的准确位置和大小。这个过程也被称为重排（reflow）。</li><li>绘制（Painting）：布局完成后，浏览器开始将元素绘制到屏幕上。这个过程包括绘制文本、颜色、图片、边框等视觉效果。</li><li>合成（Compositing）：在某些情况下，浏览器会将页面分成多个层进行绘制。最后，这些层会按照特定顺序合成为最终的页面视图。</li></ol><p>在整个解析过程中，浏览器可能还需要处理JavaScript代码。JavaScript可以通过修改DOM树、CSSOM树和触发事件等方式影响页面的呈现。</p><h2 id="说一说从输入url到页面呈现发生了什么" tabindex="-1">说一说从输入URL到页面呈现发生了什么 <a class="header-anchor" href="#说一说从输入url到页面呈现发生了什么" aria-label="Permalink to &quot;说一说从输入URL到页面呈现发生了什么&quot;">​</a></h2><p>从输入 URL 到页面呈现，经历了以下几个主要步骤：</p><ol><li><strong>地址解析</strong>：浏览器首先解析输入的 URL，提取协议、域名、端口和路径等信息。</li><li><strong>DNS 查询</strong>：浏览器通过 DNS 查询将域名解析为 IP 地址。如果浏览器或操作系统缓存中已有相应的 DNS 记录，将直接使用缓存的结果；否则，浏览器将发送请求到 DNS 服务器进行查询。</li><li><strong>建立 TCP 连接</strong>：浏览器与目标服务器建立 TCP 连接，进行三次握手。这一步确保了数据传输的可靠性。</li><li><strong>发送 HTTP 请求</strong>：浏览器构建 HTTP 请求报文，包含请求头（如 User-Agent、Accept 等）和请求体（如 POST 提交的表单数据），然后通过建立的 TCP 连接将请求报文发送给服务器。</li><li><strong>服务器响应</strong>：服务器收到请求后，处理请求并生成响应报文，包含响应头（如 Content-Type、Content-Length 等）和响应体（如请求的 HTML 文件）。服务器通过 TCP 连接将响应报文发送回浏览器。</li><li><strong>浏览器接收响应</strong>：浏览器接收并解析响应报文，提取状态码、响应头和响应体等信息。</li><li><strong>解析 HTML</strong>：浏览器开始解析 HTML 文档，构建 DOM 树。遇到外部资源（如 CSS、JavaScript、图片等），浏览器会发起额外的请求获取这些资源。</li><li><strong>解析 CSS</strong>：浏览器解析 CSS 文件，构建 CSSOM 树。CSSOM 树和 DOM 树会被合并为渲染树。</li><li><strong>执行 JavaScript</strong>：浏览器解析并执行 JavaScript 代码。注意，JavaScript 的执行可能会修改 DOM 树和 CSSOM 树，从而影响渲染树的构建。</li><li><strong>构建渲染树</strong>：浏览器将 DOM 树和 CSSOM 树合并为渲染树，包含每个可见元素的布局信息。</li><li><strong>布局</strong>：浏览器根据渲染树计算每个元素的准确位置和大小，确定页面的布局。</li><li><strong>绘制</strong>：浏览器遍历渲染树，将每个元素绘制到屏幕上。</li><li><strong>合成</strong>：在某些情况下，浏览器会将页面分成多个层进行绘制。最后，这些层会按照特定顺序合成为最终的页面视图。</li><li><strong>页面呈现</strong>：浏览器将渲染好的页面呈现给用户。</li></ol><p>总之，从输入 URL 到页面呈现，浏览器经历了一系列复杂的过程。理解这些过程有助于我们优化前端性能，提高用户体验。</p><h2 id="当前的前端渲染方式有哪些-谈谈你对它们的理解-并说说它们的优缺点是什么" tabindex="-1">当前的前端渲染方式有哪些，谈谈你对它们的理解，并说说它们的优缺点是什么？ <a class="header-anchor" href="#当前的前端渲染方式有哪些-谈谈你对它们的理解-并说说它们的优缺点是什么" aria-label="Permalink to &quot;当前的前端渲染方式有哪些，谈谈你对它们的理解，并说说它们的优缺点是什么？&quot;">​</a></h2><p>当前主要的前端渲染方式有三种：服务器端渲染（SSR）、客户端渲染（CSR）和预渲染（Prerendering）。下面分别阐述这三种渲染方式的特点及优缺点：</p><ol><li><p><strong>服务器端渲染（SSR）</strong>：</p><p>服务器端渲染指的是在服务器上将网页的 HTML、CSS 和 JavaScript 渲染成完整的 HTML 页面，然后将渲染后的页面发送给客户端。客户端接收到页面后直接展示，无需执行额外的 JavaScript。</p><ul><li>优点： <ol><li>有利于 SEO，因为搜索引擎可以直接爬取完整的 HTML 页面。</li><li>首屏加载速度较快，因为用户无需等待 JavaScript 执行完毕就能看到页面内容。</li></ol></li><li>缺点： <ol><li>服务器端压力较大，因为每次请求都需要服务器进行页面渲染。</li><li>用户交互复杂度受限，因为每次交互都可能需要重新渲染页面。</li></ol></li></ul></li><li><p><strong>客户端渲染（CSR）</strong>：</p><p>客户端渲染指的是将 HTML、CSS 和 JavaScript 发送给客户端，然后在客户端执行 JavaScript 来生成页面内容。这种方式在现代前端框架（如 React、Vue 和 Angular）中非常常见。</p><ul><li>优点： <ol><li>服务器压力较小，因为页面渲染工作由客户端完成。</li><li>用户交互体验较好，因为客户端可以实现动态的、无需刷新页面的交互。</li></ol></li><li>缺点： <ol><li>首屏加载速度较慢，因为客户端需要等待 JavaScript 执行完毕才能看到页面内容。</li><li>不利于 SEO，因为搜索引擎在爬取页面时可能无法执行 JavaScript。</li></ol></li></ul></li><li><p><strong>预渲染（Prerendering）</strong>：</p><p>预渲染是在构建过程中生成静态 HTML 文件，然后将这些静态文件部署到服务器。当用户请求页面时，服务器直接返回对应的静态 HTML 文件。这种方法适用于内容不经常变动的网站。</p><ul><li>优点： <ol><li>首屏加载速度较快，因为用户无需等待 JavaScript 执行完毕就能看到页面内容。</li><li>有利于 SEO，因为搜索引擎可以直接爬取静态 HTML 页面。</li><li>服务器压力较小，因为页面在构建过程中已经渲染完成。</li></ol></li><li>缺点： <ol><li>构建过程可能较慢，尤其是对于大型网站。</li><li>如果网站内容经常变动，需要频繁地重新构建和部署页面。</li></ol></li></ul></li></ol><p>总结：</p><p>每种渲染方式都有其优缺点，具体选择哪种方式要根据实际项目需求进行权衡。以下是一些建议：</p><ul><li>如果 SEO 对项目至关重要，而且项目内容相对稳定，则可以考虑使用预渲染或服务器端渲染。</li><li>如果项目需要提供丰富的用户交互体验，可以考虑使用客户端渲染，这样能够充分利用现代前端框架的优势。</li><li>如果项目的内容动态性较强，可以考虑使用服务器端渲染或客户端渲染。但对于客户端渲染，可能需要考虑使用服务端渲染的同构应用或者采用一些服务器端渲染辅助的技术（如 prerender.io）来提高 SEO 效果。</li><li>对于首屏加载速度有较高要求的项目，可以考虑使用服务器端渲染或预渲染。</li></ul><p>实际项目中，可以根据需求灵活地将不同渲染方式结合使用，以达到最佳的性能和用户体验。例如，可以在服务器端渲染首屏内容以提高首屏加载速度，然后在客户端渲染后续的页面内容以提供更好的交互体验。</p><h2 id="谈谈你对web-workers的理解" tabindex="-1">谈谈你对Web Workers的理解 <a class="header-anchor" href="#谈谈你对web-workers的理解" aria-label="Permalink to &quot;谈谈你对Web Workers的理解&quot;">​</a></h2><p>Web Workers 在浏览器中提供了一个单独的、并行的执行环境，可以运行长时间运行的脚本而不会阻塞 UI 线程。然而，这个执行环境与主 JavaScript 执行环境相比有一些限制。以下是主要的一些限制：</p><ol><li>无法访问 DOM：Web Workers 运行在隔离的线程中，不能直接访问网页的 DOM。任何与 UI 相关的操作都需要通过主线程完成。</li><li>无法访问全局对象：Web Workers 不能访问许多全局对象，如 <code>window</code> 对象，因为这些对象与 UI 相关或者包含与 UI 相关的功能。</li><li>无法访问某些 Web API：像 navigator.geolocation 或者 window.localStorage 这样的 Web API 无法在 Web Workers 中使用。</li><li>无法加载其他脚本：Web Workers 无法使用 <code>&lt;script&gt;</code> 标签加载其他脚本。但是，可以使用 <code>importScripts()</code> 函数来导入其他脚本。</li><li>数据传递限制：Web Workers 通过消息传递与主线程通信。这意味着所有的数据在传送时都需要被序列化和反序列化，这可能会对性能产生影响。</li><li>运行环境的限制：Web Workers 运行在不同的全局上下文中，即 <code>DedicatedWorkerGlobalScope</code>，而不是主线程的 <code>window</code>。因此，一些预期在 <code>window</code> 上下文中使用的代码在 Web Worker 中可能无法正常工作。</li></ol><p>总的来说，Web Workers 是设计用于执行计算密集型或者长时间运行的任务，而非操作 UI 或者处理与 UI 相关的逻辑。对于需要与 UI 交互的操作，仍然需要在主线程中完成。</p><h2 id="谈谈你对v8垃圾回收的理解" tabindex="-1">谈谈你对V8垃圾回收的理解？ <a class="header-anchor" href="#谈谈你对v8垃圾回收的理解" aria-label="Permalink to &quot;谈谈你对V8垃圾回收的理解？&quot;">​</a></h2><p>V8引擎主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。</p><ol><li>分代收集：V8将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用Scavenge算法进行垃圾回收，通常采用Cheney算法，将内存分为两个半区（From Space和To Space），每次垃圾回收时，会将存活的对象复制到To Space中，并清空From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。</li><li>增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。</li></ol><p>V8垃圾回收是对JavaScript垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。</p><h2 id="如何优化和减少垃圾回收的影响-从而提高应用性能" tabindex="-1">如何优化和减少垃圾回收的影响，从而提高应用性能？ <a class="header-anchor" href="#如何优化和减少垃圾回收的影响-从而提高应用性能" aria-label="Permalink to &quot;如何优化和减少垃圾回收的影响，从而提高应用性能？&quot;">​</a></h2><p>以下是一些建议和技巧来帮助优化和减少垃圾回收的影响：</p><ol><li><strong>避免全局变量</strong>：全局变量不会被垃圾回收，除非它们被设置为 <code>null</code>。只有在确实需要时才应该使用它们。</li><li><strong>使用对象池</strong>：对于频繁创建和销毁的对象（如在游戏或高性能应用中的实体），使用对象池可以重用对象而不是每次都创建新的对象。这可以避免频繁的垃圾回收。</li><li><strong>小心闭包</strong>：闭包可能会导致意外的引用，从而阻止对象被垃圾回收。确保你只在需要时使用闭包，并在不再需要它们时断开引用。</li><li><strong>手动释放大对象</strong>：对于大的数据结构或数组，如果你知道它们不再需要，可以手动将它们设置为 <code>null</code>，从而提前提示垃圾回收器。</li><li><strong>避免循环引用</strong>：确保对象之间没有循环引用，因为这可能导致它们无法被垃圾回收。</li><li><strong>使用弱引用</strong>：在合适的场景下，使用 <code>WeakMap</code> 或 <code>WeakSet</code> 可以让你存储对对象的引用，而不会阻止这些对象被垃圾回收。</li><li><strong>优化事件监听器</strong>：确保及时删除不再需要的事件监听器。未删除的事件监听器可能会导致内存泄漏。</li><li><strong>减少内存分配</strong>：减少动态创建对象、数组和闭包的频率可以帮助减少需要回收的垃圾量。</li><li><strong>使用浏览器开发者工具</strong>：浏览器提供的开发者工具（如 Chrome DevTools）可以帮助你监测和诊断内存使用情况和潜在的泄漏。</li><li><strong>考虑使用 WebAssembly</strong>：对于需要高性能和低延迟的应用，使用 WebAssembly 可能会帮助减少 JavaScript 的垃圾回收的影响，因为 WebAssembly 有自己的内存管理模型。</li></ol><hr>`,165),s=[a];function r(n,c,d,p,g,S){return e(),i("div",null,s)}const u=o(t,[["render",r]]);export{k as __pageData,u as default};
