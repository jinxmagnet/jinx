import{_ as s,o as a,c as i,R as e}from"./chunks/framework.ka86hsJC.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/frontend/react/Hooks详解/1.useCallback和useMemo.md","filePath":"articles/frontend/react/Hooks详解/1.useCallback和useMemo.md","lastUpdated":1701224209000}'),l={name:"articles/frontend/react/Hooks详解/1.useCallback和useMemo.md"},n=e(`<p><strong>先上结论</strong></p><blockquote><ul><li><p>如果想传递函数给子组件，请使用<code>useCallback</code>包裹后再传，避免子组件不必要的重复渲染，前提是子组件使用<code>memo</code>函数包裹</p></li><li><p>如果想进行大量计算，请使用<code>useMemo</code>包裹计算逻辑后再使用其返回值，避免不必要的大量重复相同计算</p></li><li><p>如果想传递对象给子组件，请使用<code>useMemo</code>包裹后再传，避免子组件不必要的重复渲染，前提是子组件使用<code>memo</code>函数包裹</p></li></ul></blockquote><p>问题：<code>React</code>组件在<code>state</code>和<code>props</code>发生变化的时候都会从头到尾重新渲染一次，而在次渲染的时候，里面普通定义的函数、对象都会重新创建一次</p><h2 id="一、usecallback" tabindex="-1">一、useCallback <a class="header-anchor" href="#一、usecallback" aria-label="Permalink to &quot;一、useCallback&quot;">​</a></h2><p><code>useCallback</code>实际目的是为了进行性能的优化，如何进行性能优化呢？</p><p><code>useCallback</code>会返回一个函数的<code>memoized</code>记忆值，在依赖不变的情况下，多次定义的时候返回的值是相同的</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> memoizedCallback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  doSomething</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [a, b])</span></span></code></pre></div><p>对于定义一个函数本身来说，使用和不使用并不会带来性能优化，其优化的点在于，将把这个函数传递给子组件时，如果该函数不发生变化，那么子组件不会重新渲染！这就是性能优化的点，我们使用<code>useCallback</code>的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存。</p><h2 id="二、usememo" tabindex="-1">二、useMemo <a class="header-anchor" href="#二、usememo" aria-label="Permalink to &quot;二、useMemo&quot;">​</a></h2><p><code>useMemo</code>实际目的是也为了进行性能的优化，如何进行性能优化呢？</p><p><code>useMemo</code>返回的也是一个 <code>memoized</code>（记忆的）值，在依赖不变的情况下，多次定义的时候返回的值是相同的</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> memoizedValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  computeValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a, b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [a, b])</span></span></code></pre></div><p>如果不使用<code>useMemo</code>，在进行大量计算操作时，每次渲染组件都会重新计算一次，使用了<code>useMemo</code>后，如果依赖不变，就不会重新计算！这就是优化的点，同时，对子组件传递相同内容的对象时，使用<code>useMemo</code>也可以进行性能优化。</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> info</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;coder&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传递给子组件,在父组件发生重新渲染时，子组件不会重新渲染</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Son</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> info</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{info}/&gt;</span></span></code></pre></div><h2 id="三、等价转换" tabindex="-1">三、等价转换 <a class="header-anchor" href="#三、等价转换" aria-label="Permalink to &quot;三、等价转换&quot;">​</a></h2><p>从上面可以看出，如果<code>useMemo</code>返回一个函数，那和<code>useCallback</code>其实是一样的</p><p><code>useCallback(fn, deps)</code>和<code>useMemo( ()=&gt;fn, deps)</code>是等价的！</p>`,17),t=[n];function p(h,o,k,d,c,r){return a(),i("div",null,t)}const E=s(l,[["render",p]]);export{u as __pageData,E as default};
